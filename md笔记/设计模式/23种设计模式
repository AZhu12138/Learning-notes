# 零、简单工厂模式

## 1、目的

![](https://azhu12138.oss-cn-shenzhen.aliyuncs.com/img/20200724223541.png)

## 2、结构：

![](https://azhu12138.oss-cn-shenzhen.aliyuncs.com/img/20200724215137.png)

## 3、优点

- 实现了**对象创建和使用的分离**；
- 客户端**无须知道所创建的具体产品类的类名**，只需要知道具体产品类所对应的参数即可；
- 通过引入xml配置文件，可以在**不修改任何客户端代码的情况下更换和增加新的具体产品类**，在一定程度上提高系统的灵活性。

## 4、缺点

- **工厂类**集中了所有产品的创建逻辑，**职责过重**，一旦不能正常工作，整个系统都会受到影响
- **增加了系统的类的数量**（引入了工厂类），增加了系统的复杂度和理解难度
- **系统扩展困难**，一旦添加新产品就要修改工厂类的逻辑
- 使用了静态的工厂方法，造成**工厂角色无法形成基于继承的等级结构**，工厂类不能得到很好地扩展。

## 5、适合使用的情况

- **工厂类类责创建的对象比较少**：由于创建的对象较少,不会造成工厂方法中的业务逻辑太过复杂
- **客户端只知道传入工厂类的参数,对于如何创建对象不关心**：客户端既不需要关心创建细节,甚至连类名都不需要记住,只需要知道类型所对应的参数。

# 一、工厂方法模式

## 1、目的

![](https://azhu12138.oss-cn-shenzhen.aliyuncs.com/img/20200726123324.png)

## 2、结构

使用了 java 的反射机制：

```java
//创建一个字符串类型的对象
Class c = Class.forName("String");
Object obj = c.newInstance();
return obj;
```

![](https://azhu12138.oss-cn-shenzhen.aliyuncs.com/img/20200726123037.png)

---------------我是图形分界线------------------

![](https://azhu12138.oss-cn-shenzhen.aliyuncs.com/img/20200726124657.png)

## 3、优点

- 厂方法用来创建客户所需要的产品，同时还**向客户隐藏了哪种具体产品类将被实例化这一细节**
- 能够**让工厂自主确定创建何种产品对象**，而如何创建这个对象的细节则完全封装在具体工厂内部
- 在系统中加入新产品时，**完全符合开闭原则**

## 4、缺点

- 系统中**类的个数将成对增加**，在一定程度上增加”了系统的复杂度，会给系统带来一些额外的开销
- **增加了系统的抽象性和理解难度**

## 5、适合使用的情况

- **客户端不知道它所需要的对象的类**（客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体产品对象由具体工厂类创建）
- **抽象工厂类通过其子类来指定创建哪个对象**

# 二、抽象工厂模式

## 1、目的

![](https://azhu12138.oss-cn-shenzhen.aliyuncs.com/img/20200726131245.png)

## 2、结构

一个工厂生产一个产品族

![](https://azhu12138.oss-cn-shenzhen.aliyuncs.com/img/20200726131724.png)

## 3、优点

- **隔离了具体类的生成**，使得客户端并不需要知道什么被创建
- 当一个产品族中的多个对象被设计成一起工作时，它**能够保证客户端始终只使用同一个产品族中的对象**
- **增加新的产品族很方便**，无须修改已有系统，**符合开闭原则**

## 4、缺点

- **增加新的产品等级结构麻烦**，需要对原有系统进行较大的修改，甚至需要修改抽象层代码，这显然会带来较大的不便，**违背了开闭原则**

## 5、适合使用的情况

- 一个系统**不应当依赖于产品类实例如何被创建、组合和表达的细节**
- 系统中有多于一个的产品族,但**每次只使用其中某一产品族**
- **属于同一个产品族的产品将在一起使用**，这一约束必须在系统的设计中体现出来
- **产品等级结构稳定**，在设计完成之后不会向系统中增加新的产品等级结构或者删除已有的产品等级结构

# 三、建造者模式

## 1、目的

![](https://azhu12138.oss-cn-shenzhen.aliyuncs.com/img/20200729205125.png)

## 2、结构

![](https://azhu12138.oss-cn-shenzhen.aliyuncs.com/img/20200729205514.png)

---------------我是图形分界线------------------

![](https://azhu12138.oss-cn-shenzhen.aliyuncs.com/img/20200729210143.png)

## 3、优点

- 客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得**相同的创建过程可以创建不同的产品对象**
- **每一个具体建造者都相对独立**，与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者，扩展方便，**符合开闭原则**
- **可以更加精细地控制产品的创建过程**

## 4、缺点

- 建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，**如果产品之间的差异性很大，不适合使用建造者模式**，因此其**使用范围受到一定的限制**
- **如果产品的内部变化复杂，可能会需要定义很多具体建造者类来实现这种变化**，导致系统变得很庞大，增加了系统的理解难度和运行成本

## 5、适合使用的情况

- **需要生成的产品对象有复杂的内部结构**，这些产品对象通常包含多个成员变量
- **需要生成的产品对象的属性相互依赖**，需要指定其生成顺序
- **对象的创建过程独立于创建该对象的类**。在建造者模式中通过引入了指挥者类，将创建过程封装在指挥者类中，而不在建造者类和客户类中
- **隔离复杂对象的创建和使用**，并使得相同的创建过程可以创建不同的产品

# 四、原型模式

## 1、目的

![](https://azhu12138.oss-cn-shenzhen.aliyuncs.com/img/20200729213242.png)

## 2、结构

![](https://azhu12138.oss-cn-shenzhen.aliyuncs.com/img/20200729213612.png)

- **浅克隆与深克隆：**

![](https://azhu12138.oss-cn-shenzhen.aliyuncs.com/img/20200729214341.png)

![](https://azhu12138.oss-cn-shenzhen.aliyuncs.com/img/20200729214547.png)

---------------我是图形分界线------------------

![](https://azhu12138.oss-cn-shenzhen.aliyuncs.com/img/20200729214833.png)

![](https://azhu12138.oss-cn-shenzhen.aliyuncs.com/img/20200729215455.png)

## 3、优点

- **简化对象的创建过程**，通过复制一个已有实例可以**提高新实例的创建效率**
- **扩展性较好**
- **简化创建结构**，原型模式中产品的复制是通过封装在原型类中的克隆方法实现的，无须专门的工厂类来创建产品
- 可以**使用深克隆的方式保存对象的状态**,以便在需要的时候使用,可辅助实现**撤销操作**

## 4、缺点

- **需要为每一个类配备一个克隆方法**，而且该克隆方法位于一个类的内部，当对已有的类进行改造时，需要修改源代码，**违背了开闭原则**
- **在实现深克隆时需要编写较为复杂的代码**，而且当对象之间存在多重的嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来可能会比较麻烦

## 5、适合使用的情况

- **创建新对象成本较大**，新对象可以通过复制已有对象来获得，如果是相似对象，则可以对其成员变量稍作修改
- 系统要保存对象的状态，而**对象的状态变化很小**
- 需要**避免使用分层次的工厂类**来创建分层次的对象

# 五、单例模式

## 1、目的

![](https://azhu12138.oss-cn-shenzhen.aliyuncs.com/img/20200801142949.png)

## 2、结构

![](https://azhu12138.oss-cn-shenzhen.aliyuncs.com/img/20200801143157.png)

- **饿汉式 与 懒汉式 单例类**

![](https://azhu12138.oss-cn-shenzhen.aliyuncs.com/img/20200801143716.png)

- 饿汉式存在的多线程的问题：**内存资源的浪费**

![](https://azhu12138.oss-cn-shenzhen.aliyuncs.com/img/20200801143928.png)

- 懒汉式存在的多线程的问题：

![](https://azhu12138.oss-cn-shenzhen.aliyuncs.com/img/20200801145620.png)

- 解决方法：**双重锁定**

**volatile** 关键字：用于**取消java虚拟机对java代码的优化**，否则java虚拟机会认为代码中的两个 if 语句是重复的语句，会对其进行优化。

**synchronized** 关键字：用于对代码块的锁定，当该代码块被一个方法执行时，其他方法需要**排队等待**前面的方法执行该代码块完毕后才能执行。

![](https://azhu12138.oss-cn-shenzhen.aliyuncs.com/img/20200801145940.png)

- **饿汉式单例类与懒汉式单例类的比较**
- **饿汉式单例类：**无须考虑多个线程同时访问的问题；调用速度和反应时间优于懒汉式单例；资源利用效率不及懒汉式单例；系统加载时间可能会比较长
- **懒汉式单例类：**实现了延迟加载；必须处理好多个线程同时访问的问题；需通过双重检查锁定等机制进行控制，将导致系统性能受到一定影响

使用静态内部类实现单例模式：

![1596269138390](C:\Users\nobod\AppData\Roaming\Typora\typora-user-images\1596269138390.png)

## 3、优点

- 提供了**对唯一实例的受控访问**

- 可以**节约系统资源，提高系统的性能**

- 允许可变数目的实例（**多例类**）

  ![](https://azhu12138.oss-cn-shenzhen.aliyuncs.com/img/20200801160817.png)

## 4、缺点

- **扩展困难（缺少抽象层）**
- **单例类的职责过重**

## 5、适合使用的情况

- 系统**只需要一个实例对象**，或者因为资源消耗太大而**只允许创建一个对象**
- 客户调用类的单个实例**只允许使用一个公共访问点**，除了该公共访问点，不能通过其他途径访问该实例

# 六、适配器模式

## 1、目的

![](https://azhu12138.oss-cn-shenzhen.aliyuncs.com/img/20200801161343.png)

## 2、结构

![](https://azhu12138.oss-cn-shenzhen.aliyuncs.com/img/20200801161757.png)

---------------我是图形分界线------------------

![](https://azhu12138.oss-cn-shenzhen.aliyuncs.com/img/20200801162436.png)

## 3、优点

- **将目标类和适配者类解耦，**通过引入一个适配器类来重用现有的适配者类，无须修改原有结构
- **增加了类的透明性和复用性，**提高了适配者的复用性，同一个适配者类可以在多个不同的系统中复用
- **灵活性和扩展性非常好**
- **类适配器模式：**置换一些适配者的方法很方便
- **对象适配器模式：**可以把多个不同的适配者适配到同一个目标，还可以适配一个适配者的子类

## 4、缺点

- **类适配器模式:**
  （1）一次最多只能适配一个适配者类,不能同时适配多个适配者
  （2）适配者类不能为最终类
  （3）目标抽象类只能为接口，不能为类
- **对象适配器模式：**在适配器中置换适配者类的某些方法比较麻烦

## 5、适合使用的情况

- 系统**需要使用一些现有的类，而这些类的接口不符合系统的需要**，甚至没有这些类的源代码
- **创建一个可以重复使用的类**，用于和一些彼此之间没有太大关联的类，包括一些可能在将来引进的类一起工作

# 七、桥接模式

## 1、目的

![](https://azhu12138.oss-cn-shenzhen.aliyuncs.com/img/20200805165057.png)

## 2、结构

![](https://azhu12138.oss-cn-shenzhen.aliyuncs.com/img/20200805165741.png)

---------------我是图形分界线------------------

![](https://azhu12138.oss-cn-shenzhen.aliyuncs.com/img/20200805170346.png)

---------------我是图形分界线------------------

![](https://azhu12138.oss-cn-shenzhen.aliyuncs.com/img/20200805170741.png)

## 3、优点

- **分离抽象接口及其实现部分**
- 可以取代多层继承方案，**极大地减少了子类的个数**
- **提高了系统的可扩展性**，在两个变化维度中任意扩展一个维度，不需要修改原有系统，**符合开闭原则**

## 4、缺点

- **会增加系统的理解与设计难度**，由于关联关系建立在抽象层，要求开发者一开始就要针对抽象层进行设计与编程
- **正确识别出系统中两个独立变化的维度并不是一件容易的事情**

## 5、适合使用的情况

- 需要在抽象化和具体化之间增加更多的灵活性，**避免在两个层次之间建立静态的继承关系**
- 抽象部分和实现部分可以以继承的方式**独立扩展而互不影响**
- 一个类**存在两个（或多个）独立变化的维度**，且这两个（或多个）维度都需要独立地进行扩展
- **不希望使用继承**或**因为多层继承导致系统类的个数急剧增加**的系统

# 八、组合模式

## 1、目的

![](https://azhu12138.oss-cn-shenzhen.aliyuncs.com/img/20200805201011.png)

## 2、结构

![](https://azhu12138.oss-cn-shenzhen.aliyuncs.com/img/20200805201722.png)

---------------我是图形分界线------------------

![](https://azhu12138.oss-cn-shenzhen.aliyuncs.com/img/20200805201925.png)

- **透明组合模式 和 安全组合模式：**

![](https://azhu12138.oss-cn-shenzhen.aliyuncs.com/img/20200805203245.png)

![](https://azhu12138.oss-cn-shenzhen.aliyuncs.com/img/20200805203408.png)

---------------我是图形分界线------------------

![](https://azhu12138.oss-cn-shenzhen.aliyuncs.com/img/20200805203515.png)

## 3、优点

- 可以**清楚地定义分层次的复杂对象**，表示对象的全部或部分层次，**让客户端忽略了层次的差异**，方便对整个层次结构进行控制
- 客户端可以**一致地使用一个组合结构或其中单个对象**，不必关心处理的是单个对象还是整个组合结构，简化了客户端代码
- 增加新的容器构件和叶子构件都很方便，**符合开闭原则**
- 为**树形结构的面向对象实现**提供了一种灵活的解决方案

## 4、缺点

- **在增加新构件时很难对容器中的构件类型进行限制**

## 5、适合使用的情况

- 在**具有整体和部分的层次结构**中，希望通过一种方式忽略整体与部分的差异**客户端可以一致地对待它们**
- 在一个使用**面向对象语言开发的系统中需要处理一个树形结构**
- 在一个系统中**能够分离出叶子对象和容器对象**，而且它们的类型不固定，需要增加一些新的类型

# 九、装饰模式

## 1、目的

![](https://azhu12138.oss-cn-shenzhen.aliyuncs.com/img/20200806202544.png)

## 2、结构

![](https://azhu12138.oss-cn-shenzhen.aliyuncs.com/img/20200806202928.png)

**（1）透明装饰模式**

- **透明(Transparent)装饰模式：**要求**客户端完全针对抽象编程**，装饰模式的透明性要求客户端程序不应该将对象声明为具体构件类型或具体装饰类型，而**应该全部声明为抽象构件类型**
- 对于客户端而言，**具体构件对象和具体装饰对象没有任何区别**
- 可以让**客户端透明地使用装饰之前的对象和装饰之后的对象**，无须关心它们的区别
- **可以对一个已装饰过的对象进行多次装饰**，得到更为复杂、功能更为强大的对象
- **无法在客户端单独调用新增方法** addedBehavior()

**（2）半透明装饰模式**

- **半透明(Semi-transparent)装饰模式：用具体装饰类型来定义装饰之后的对象，而具体构件使用抽象构件类型来定义**
- 对于客户端而言，**具体构件类型无须关心，是透明的**；但是**具体装饰类型必须指定，这是不透明的**
- 可以给系统带来更多的灵活性，**设计相对简单**，使用起来也非常方便
- 客户端使用具体装饰类型来定义装饰后的对象，因此**可以单独调用 addedBehavior() 方法**
- 最大的缺点在于**不能实现对同一个对象的多次装饰**，而且**客户端需要有区别地对待装饰之前的对象和装饰之后的对象**

![](https://azhu12138.oss-cn-shenzhen.aliyuncs.com/img/20200806204802.png)

## 3、优点

- 对于扩展一个对象的功能，**装饰模式比继承更加灵活，不会导致类的个数急剧增加**
- 可以**通过一种动态的方式来扩展一个对象的功能**，通过配置文件可以在运行时选择不同的具体装饰类，从而实现不同的行为
- 可以对一个对象进行**多次装饰**
- 具体构件类与具体装饰类可以独立变化，**用户可以根据需要增加新的具体构件类和具体装饰类**，且原有类库代码无须改变，**符合开闭原则**

## 4、缺点

- 使用装饰模式进行系统设计时将**产生很多小对象**，大量小对象的产生势必会占用更多的系统资源，**在一定程度上影响程序的性能**
- **比继承更加易于出错，排错也更困难**，对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为烦琐

## 5、适合使用的情况

- 在不影响其他对象的情况下，**以动态、透明的方式给单个对象添加职责**
- 当**不能采用继承的方式对系统进行扩展**或者**采用继承不利于系统扩展和维护**时可以使用装饰模式

# 十、外观模式

## 1、目的

![](https://azhu12138.oss-cn-shenzhen.aliyuncs.com/img/20200809215018.png)

---------------我是图形分界线------------------

![](https://azhu12138.oss-cn-shenzhen.aliyuncs.com/img/20200809215438.png)

## 2、结构

![](https://azhu12138.oss-cn-shenzhen.aliyuncs.com/img/20200809215647.png)

---------------我是图形分界线------------------

![](https://azhu12138.oss-cn-shenzhen.aliyuncs.com/img/20200809220100.png)

## 3、优点

- 它对客户端屏蔽了子系统组件，**减少了客户端所需处理的对象数目**，并使得子系统使用起来更加容易
- 它**实现了子系统与客户端之间的松耦合关系**，这使得子系统的变化不会影响到调用它的客户端，只需要调整外观类即可
- **一个子系统的修改对其他子系统没有任何影响**，而且**子系统的内部变化也不会影响到外观对象**

## 4、缺点

- **不能很好地限制客户端直接使用子系统类**，如果对客户端访问子系统类做太多的限制则减少了可变性和灵活性
- 如果设计不当，**增加新的子系统可能需要修改外观类的源代码，违背了开闭原则**

## 5、适合使用的情况

- **要为访问一系列复杂的子系统提供一个简单入口**
- **客户端程序与多个子系统之间存在很大的依赖性**
- 在层次化结构中，可以**使用外观模式的定义系统中每一层的入口**，层与层之间不直接产生联系，而是**通过外观类建立联系，降低层之间的耦合度**

# 十一、享元模式

## 1、动机

![](https://azhu12138.oss-cn-shenzhen.aliyuncs.com/img/20200822213943.png)

## 2、定义

- 享元模式(Flyweight Pattern):**运用共享技术有效地支持大量细粒度对象的复用**
- 可以实现对象的多次复用
- 由于享元模式要求能够共享的对象必须是细粒度对象，因此它又称为**轻量级模式**，它是一种**对象结构型模式**

## 3、结构

![](https://azhu12138.oss-cn-shenzhen.aliyuncs.com/img/20200822214307.png)

## 4、分析

- **内部状态(Intrinsic State)**∶存储在享元对象内部并且**不会随环境改变而改变的状态，内部状态可以共享**（例如∶字符的内容）
- **外部状态(Extrinsic State)**:**随环境改变而改变的、不可以共享的状态**。享元对象的外部状态通常由客户端保存，并在享元对象被创建之后，需要使用的时候再传入到享元对象内部。一个外部状态与另一个外部状态之间是相互独立的（例如∶字符的颜色和大小)

## 5、优点

- 可以**减少内存中对象的数量**，使得相同或者相似的对象在内存中只保存一份，从而可以**节约系统资源，提高系统性能**
- 外部状态相对独立，而且不会影响其内部状态，从而使得**享元对象可以在不同的环境中被共享**

## 6、缺点

- 使得**系统变得复杂**，需要分离出内部状态和外部状态，这使得程序的逻辑复杂化
- 为了使对象可以共享，享元模式需要将享元对象的部分状态外部化，而**读取外部状态将使得运行时间变长**

## 7、适合使用的情况

- **一个系统有大量相同或者相似的对象**，造成内存的大量耗费
- **对象的大部分状态都可以外部化**，可以将这些外部状态传入对象中
- 在使用享元模式时需要维护一个存储享元对象的享元池，而这需要耗费一定的系统资源，因此，**在需要多次重复使用享元对象时才值得使用享元模式**

# 十二、代理模式

## 1、动机

![](https://azhu12138.oss-cn-shenzhen.aliyuncs.com/img/20200822220244.png)

## 2、定义

- 代理模式 (Proxy Pattern)∶**给某一个对象提供一个代理，并由代理对象控制对原对象的引用**
- **对象结构型模式**
- 代理对象可以在客户端和目标对象之间起到**中介的作用**
- 通过代理对象**去掉客户不能看到的内容和服务**或者**添加客户需要的额外的新服务**

## 3、结构

![](https://azhu12138.oss-cn-shenzhen.aliyuncs.com/img/20200822220638.png)

---------------我是图形分界线------------------

![](https://azhu12138.oss-cn-shenzhen.aliyuncs.com/img/20200822222819.png)

## 4、分析

**几种常用的代理模式：**

- **远程代理(Remote Proxy)**:为一个位于不同的地址空间的对象提供一个本地的代理对象，这个不同的地址空间可以在同一台主机中，也可以在另一台主机中，远程代理又称为大使(Ambassador)
- **虚拟代理(Virtual Proxy)**∶如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建
- **保护代理(Protect Proxy)**︰控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限
- **缓冲代理(Cache Proxy)**:为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果
- **智能引用代理(Smart Reference Proxy)**:当一个对象被引用时，提供一些额外的操作，例如将对象被调用的次数记录下来等

## 5、优点

- 能够协调调用者和被调用者，在一定程度上**降低了系统的耦合度**
- 客户端可以针对抽象主题角色进行编程，**增加和更换代理类无须修改源代码，符合开闭原则**，系统具有较好的灵活性和可扩展性
- **远程代理**∶可以将一些消耗资源较多的对象和操作移至性能更好的计算机上，提高了系统的整体运行效率
- **虚拟代理**︰通过一个消耗资源较少的对象来代表一个消耗资源较多的对象，可以在一定程度上节省系统的运行开销
- **缓冲代理**∶为某一个操作的结果提供l临时的缓存存储空间，以便在后续使用中能够共享这些结果，优化系统性能，缩短执行时间
- **保护代理**∶可以控制对一个对象的访问权限，为不同用户提供不同级别的使用权限

## 6、缺点

- 由于在客户端和真实主题之间增加了代理对象，因此**有些类型的代理模式可能会造成请求的处理速度变慢**（例如保护代理）
- 实现代理模式需要额外的工作，而且**有些代理模式的实现过程较为复杂**（例如远程代理）

## 7、适合使用的情况

- 当客户端对象需要访问远程主机中的对象时可以使用**远程代理**
- 当需要用一个消耗资源较少的对象来代表一个消耗资源较多的对象，从而降低系统开销、缩短运行时间时可以使用**虚拟代理**
- 当需要为某一个被频繁访问的操作结果提供一个临时存储空间，以供多个客户端共享访问这些结果时可以使用**缓冲代理**
- 当需要控制对一个对象的访问，为不同用户提供不同级别的访问权限时可以使用**保护代理**
- 当需要为一个对象的访问（引用）提供一些额外的操作时可以使用**智能引用代理**

# 十三、职责链模式

## 1、动机

![](https://azhu12138.oss-cn-shenzhen.aliyuncs.com/img/20200823150903.png)

## 2、定义

- 职责链模式(Chain of Responsibility Pattern)：避免请求发送者与接收者耦合在一起，**让多个对象都有可能接收请求**。将这些对象连接成一条链，并且**沿着这条链传递请求**，直到有对象处理它为止。
- **对象行为型模式**

## 3、结构

![](https://azhu12138.oss-cn-shenzhen.aliyuncs.com/img/20200823151401.png)

## 4、分析

- 将**请求的处理者组织成一条链**，并让请求沿着链传递，由链上的处理者对请求进行相应的处理
- **客户端无须关心请求的处理细节以及请求的传递**，只需将请求发送到链上，将请求的发送者和请求的处理者解耦

## 5、优点

- 使得一个对象无须知道是其他哪一个对象处理其请求，**降低了系统的耦合度**
- **可简化对象之间的相互连接**
- 给对象**职责的分配带来更多的灵活性**
- **增加一个新的具体请求处理者时无须修改原有系统的代码**，只需要在客户端重新建链即可

## 6、缺点

- **不能保证请求一定会被处理**
- 对于比较长的职责链，**系统性能将受到一定影响**，在进行**代码调试时不太方便**
- 如果建链不当，**可能会造成循环调用**，将导致系统陷入死循环

## 7、适合使用的情况

- **有多个对象可以处理同一个请求**，具体哪个对象处理该请求**待运行时刻再确定**
- 在不明确指定接收者的情况下，**向多个对象中的一个提交一个请求**
- **可动态指定一组对象处理请求**

# 十四、命令模式

## 1、动机

![](https://azhu12138.oss-cn-shenzhen.aliyuncs.com/img/20200823153323.png)

## 2、定义

- 命令模式(Command Pattern)：**将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。**
- 命令模式是一种**对象行为型模式**，其别名为动作(Action)模式或事务(Transaction)模式

## 3、结构

![](https://azhu12138.oss-cn-shenzhen.aliyuncs.com/img/20200823153826.png)

---------------我是图形分界线------------------

![](https://azhu12138.oss-cn-shenzhen.aliyuncs.com/img/20200823154446.png)

## 4、分析

- **将请求发送者和接收者完全解耦**
- 发送者与接收者之间**没有直接引用关系**
- **发送请求的对象只需要知道如何发送请求**，而不必知道如何完成请求
- 命令模式的**本质是对请求进行封装**
- **一个请求对应于一个命令**,将发出命令的责任和执行命令的责任分开

## 5、优点

- **降低系统的耦合度**
- 新的命令可以很容易地加入到系统中，**符合开闭原则**
- 可以比较容易地设计一个**命令队列**或**宏命令（组合命令）**
- 为**请求的撤销(Undo)和恢复(Redo)操作**提供了一种设计和实现方案

## 6、缺点

- 使用命令模式**可能会导致某些系统有过多的具体命令类**（针对每一个对请求接收者的调用操作都需要设计一个具体命令类）

## 7、适合使用的情况

- 需要**将请求调用者和请求接收者解耦**，使得调用者和接收者不直接交互
- 需要**在不同的时间指定请求、将请求排队和执行请求**
- 需要**支持命令的撤销(Undo)操作和恢复(Redo)操作**
- 需要将一组操作组合在一起形成**宏命令**

# 十五、解释器模式

## 1、动机

![](https://azhu12138.oss-cn-shenzhen.aliyuncs.com/img/20200905143313.png)

## 2、定义

- 解释器模式(Interpreter Pattern)∶**定义一个语言的文法，并且建立一个解释器来解释该语言中的句子。**
- 此处，“语言”是指使用规定格式和语法的代码
- 它是一种**类行为型模式**

## 3、结构

![](https://azhu12138.oss-cn-shenzhen.aliyuncs.com/img/20200905143949.png)

## 4、分析

- 是一种**使用频率相对较低但学习难度相对较大**的设计模式，用于描述**如何使用面向对象语言构成一个简单的语言解释器**
- 能够**加深对面向对象思想的理解**，并且**理解编程语言中文法规则的解释过程**

![](https://azhu12138.oss-cn-shenzhen.aliyuncs.com/img/20200905144637.png)

**环境类Context :**

- 用于**存储一些全局信息**，一般包含一个HashMap或ArrayList等类型的**集合对象（也可以直接由HashMap等集合类充当环境类）**，存储一系列公共信息，例如变量名与值的映射关系(key/value)等，**用于在执行具体的解释操作时从中获取相关信息**
- 可以在环境类中**增加一些所有表达式解释器都共有的功能**，以**减轻解释器的职责**
- 当系统无须提供全局公共信息时**可以省略环境类，根据实际情况决定是否需要环境类**

## 5、优点

- **易于改变和扩展文法**
- 可以**方便地实现一个简单的语言**
- **实现文法较为容易**（有自动生成工具）
- **增加新的解释表达式较为方便**

## 6、缺点

- 对于**复杂文法难以维护**
- **执行效率较低**

- ## 7、适合使用的情况

- 可以将一个需要解释执行的语言中的句子**表示为一棵抽象语法树**

- 一些重复出现的问题可以**用一种简单的语言来进行表达**

- 一个语言的**文法较为简单**

- **执行效率不是关键问题**

# 十六、迭代器模式

## 1、动机

![](https://azhu12138.oss-cn-shenzhen.aliyuncs.com/img/20200905150021.png)

## 2、定义

- 迭代器模式(Iterator Pattern)∶**提供一种方法来访问聚合对象，而不用暴露这个对象的内部表示。**
- 其别名为**游标(Cursor)**
- 迭代器模式是一种**对象行为型模式**

## 3、结构

![](https://azhu12138.oss-cn-shenzhen.aliyuncs.com/img/20200905150329.png)

## 4、分析

- 聚合对象的两个职责︰
  **存储数据**，聚合对象的基本职责
  **遍历数据**，既是可变化的，又是可分离的
- **将遍历数据的行为从聚合对象中分离出来**，封装在迭代器对象中
- 由迭代器来提供遍历聚合对象内部数据的行为，**简化聚合对象的设计，更符合单一职责原则**

## 5、优点

- 支持**以不同的方式遍历一个聚合对象，在同一个聚合对象上可以定义多种遍历方式**
- **简化了聚合类**
- 由于引入了抽象层，**增加新的聚合类和迭代器类都很方便**，无须修改原有代码，符合开闭原则

## 6、缺点

- 在增加新的聚合类时需要对应地增加新的迭代器类，**类的个数成对增加**，这在一定程度上**增加了系统的复杂性**
- **抽象迭代器的设计难度较大，需要充分考虑到系统将来的扩展**。在自定义迭代器时，**创建一个考虑全面的抽象迭代器并不是一件很容易的事情**

## 7、适合使用的情况

- 访问一个聚合对象的内容而**无须暴露它的内部表示**
- 需要**为一个聚合对象提供多种遍历方式**
- **为遍历不同的聚合结构提供一个统一的接口**，在该接口的实现类中为不同的聚合结构提供不同的遍历方式，**而客户端可以一致性地操作该接口**

# 十七、中介者模式

## 1、动机

## 2、定义

## 3、结构

## 4、分析

## 5、优点

## 6、缺点

## 7、适合使用的情况

# 十八、备忘录模式

## 1、动机

## 2、定义

## 3、结构

## 4、分析

## 5、优点

## 6、缺点

## 7、适合使用的情况

# 十九、观察者模式

## 1、动机

## 2、定义

## 3、结构

## 4、分析

## 5、优点

## 6、缺点

## 7、适合使用的情况

# 二十、状态模式

## 1、动机

## 2、定义

## 3、结构

## 4、分析

## 5、优点

## 6、缺点

## 7、适合使用的情况

# 二十一、策略模式

## 1、动机

## 2、定义

## 3、结构

## 4、分析

## 5、优点

## 6、缺点

## 7、适合使用的情况

# 二十二、模板方法模式

## 1、动机

## 2、定义

## 3、结构

## 4、分析

## 5、优点

## 6、缺点

## 7、适合使用的情况

# 二十三、访问者模式

## 1、动机

## 2、定义

## 3、结构

## 4、分析

## 5、优点

## 6、缺点

## 7、适合使用的情况

