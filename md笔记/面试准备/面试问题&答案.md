1、计算机基础

## 1.1计算机网络

#### HTTP状态码？



#### HTTPS和HTTP的区别？



#### 浏览器输入URL之后会发生什么？



#### TCP三次握手？



#### TCP四次挥手？



#### TCP和UDP的区别？



#### TCP首部？



#### UDP首部？





## 1.2操作系统



## 1.3数据结构与算法



# 2、Java

## 2.1 Java基础

#### ”static”关键字是什么意思？

 成员变量、成员方法可以直接通过类来访问，不需要通过类的实例。 

#### Java中是否可以覆盖(override)一个private或者是static的方法？ 

- Java中static方法不能被覆盖，因为：
  - 方法覆盖是基于**运行时动态绑定**的，而static方法是**编译时静态绑定**的。
  - static方法跟类的任何实例都不相关，所以概念上不适用。
- java中也不可以覆盖private的方法，因为：
  - private修饰的变量和方法只能在当前类中使用，如果是其他的类继承当前类是不能访问到private变量或方法的，当然也不能覆盖。



#### 是否可以在static环境中访问非static变量？

- static变量是属于类的，它在所有的实例中的值是一样的。
- 当类被Java虚拟机加载的时候，会对static变量进行初始化。
- 如果你的代码尝试不用实例来访问非static的变量，编译器会报错，因为这些变量还没有被创建出来，还没有跟任何实例关联上。



#### Java中，什么是构造方法？什么是构造方法重载？

- 当新对象被创建的时候，构造方法会被调用。
- 每一个类都有构造方法。在程序员没有给类提供构造方法的情况下，Java编译器会为这个类创建一个默认的构造方法。
- Java中构造方法重载和方法重载很相似。可以为一个类创建多个构造方法。每一个构造方法必须有它自己唯一的参数列表。
  

####  接口和抽象类的区别是什么？ 

- 接口中所有的方法隐含的都是抽象的。而抽象类则可以同时包含抽象和非抽象的方法。
- 类可以实现很多个接口，但是只能继承一个抽象类
- 类可以不实现抽象类和接口声明的所有方法，当然，在这种情况下，类也必须得声明成是抽象的。
  抽象类可以在不提供接口方法实现的情况下实现接口。
- 接口中声明的变量默认都是final的。抽象类可以包含非final的变量。
- 接口中的成员函数默认是public的。抽象类的成员函数可以是private，protected或者是public。
- 接口是绝对抽象的，不可以被实例化，抽象类也不可以被实例化。 



#### Java中是如何支持正则表达式操作的？

- Java中的String类提供了支持正则表达式操作的方法，

  包括：matches()、replaceAll()、replaceFirst()、split()。

此外，Java中可以用**Pattern类**表示正则表达式对象，它提供了丰富的API进行各种正则表达式操作，如：

```java
`import` `java.util.regex.Matcher;``import` `java.util.regex.Pattern;``class` `RegExpTest {``  ``public` `static` `void` `main(String[] args) {``    ``String str = ``"成都市(成华区)(武侯区)(高新区)"``;``    ``Pattern p = Pattern.compile(``".*?(?=\\()"``);``    ``Matcher m = p.matcher(str);``    ``if``(m.find()) {``      ``System.out.println(m.group());``    ``}``  ``}``}`
```



#### 正则表达式及其用途?

- 正则表达式就是用来查找**符合某些复杂规则的字符串**的。
- 正则表达式就是一段记录文本规则的**代码**。
- 因为计算机处理的信息更多的时候不是数值而是字符串，所以正则表达式就是在进行**字符串匹配**和**处理**的时候最为强大的工具，绝大多数语言都提供了对正则表达式的支持。 



#### &和&&的区别？

- &运算符有两种用法：按位与和逻辑与。**&&运算符是短路与运算。**

逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是true整个表达式的值才是true。

**&&之所以称为短路运算是因为：如果&&左边的表达式的值是false，右边的表达式会被直接短路掉，不会进行运算。**

很多时候我们可能都需要用&&而不是&，例如在验证用户登录时判定用户名不是null而且不是空字符串，应当写为：username != null &&!username.equals("")，二者的顺序不能交换，更不能用&运算符，因为第一个条件如果不成立，根本不能进行字符串的equals比较，否则会产生NullPointerException异常。 



#### int和Integer有什么区别？

Java是一个面向对象编程语言，但是为了编程的方便还是引入了**基本数据类型**，但是为了能够将这些基本数据类型当成对象操作，Java为每一个基本数据类型都引入了对应的**包装类型**，

- **int的包装类就是Integer**，从Java 5开始引入了**自动装箱、拆箱机制**，使得二者可以相互转换。

Java 为每个原始类型提供了包装类型：

- 原始类型: boolean，char，byte，short，int，long，float，double
- 包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double 

**自动装箱**是Java编译器在基本数据类型和对应的对象包装类型之间做的一个转化。

- 比如：把int转化成Integer，double转化成Double，等等。反之就是自动拆箱。 



#### 如何输出一个某种编码的字符串？

可以通过String类型的字符串对象调用`getBytes()`方法，获得对应的字节流数据，再通过new String()的构造方法，传入刚才的字节流和对应需要的编码规则GBK，创建出一个对应编码的字符串。

```java
Public String translate (String str) {
    String tempStr = “”;
    try {
        tempStr = new String(str.getBytes(“ISO-8859-1″), “GBK”);
        tempStr = tempStr.trim();
    }
    catch (Exception e) {
        System.err.println(e.getMessage());
    }
    return tempStr;
}
```



#### String 和StringBuffer的区别？

String和StringBuffer都都可以**储存和操作字符串**。

- String类提供了数值不可改变的字符串，该字符串存储在常量池中。
- StringBuffer类提供的字符串进行修改。

我们可以使用StringBuffer来动态构造字符数据。



#### String是最基本的数据类型吗?

String不是基本的数据类型，而是一种引用类型，它主要是为了方便字符串的处理而出现的。

String类是final类型的，因此不可以继承这个类、不能修改这个类。 



#### 重写和重载的区别？

- **重写是指子类对父类方法的一种重写，** 只能比父类抛出更少的异常，访问权限不能比父类的小，被覆写的方法不能是 private 的，否则只是在子类中重新定义了一个新方法。

- **重载表示同一个类中可以有多个名称相同的方法，但这些方法的参数列表各不相同。**

  构成重载的条件有：参数类型不同、参数个数不同、参数顺序不同。



####  请你解释什么是值传递和引用传递？

- 值传递是对基本型变量而言的,传递的是该变量的一个副本,改变副本不影响原变量.
- 引用传递一般是对于对象型变量而言的,传递的是该对象地址的一个副本, 并不是原对象本身 。 所以对引用对象进行操作会同时改变原对象。

一般认为，java内的传递都是值传递。



#### Lamda表达式的优缺点？

优点：

- 简洁。
- 非常容易并行计算。
- 可能代表未来的编程趋势。

缺点：

- 若不用并行计算，很多时候计算速度没有比传统的 for 循环快。（并行计算有时需要预热才显示出效率优势）
- 不容易调试。
- 若其他程序员没有学过 lambda 表达式，代码不容易让其他语言的程序员看懂。



#### Java集合类框架的基本接口有哪些？

Java集合类里面最基本的接口有：

- Collection：代表一组对象，每一个对象都是它的子元素。
- Set：不包含重复元素的Collection。
- List：有顺序的collection，并且可以包含重复元素。
- Map：可以把键(key)映射到值(value)的对象，键不能重复。



#### Map的分类和常见的情况？

java为数据结构中的**映射**定义了一个接口java.util.Map，它有四个实现类，分别是：

- HashMap、Hashtable、LinkedHashMap、TreeMap

**Map主要用于存储健值对，根据键得到值，因此不允许键重复，但允许值重复。**

**HashMap：**

- 是一个最常用的Map，它根据键的HashCode值存储数据，根据键可以直接获取它的值，具有很快的访问速度，遍历时，取得数据的顺序是完全随机的。 
- HashMap最多只允许一条记录的键为Null，允许多条记录的值为 Null。
- HashMap不支持线程的同步，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。如果需要同步，可以用ConcurrentHashMap。

**Hashtable：**

- 与 HashMap类似，不同的是：它不允许记录的键或者值为空；
- 它使用 synchronized 支持线程的同步，即任一时刻只有一个线程能写Hashtable，因此也导致了 Hashtable在写入时会比较慢。

**LinkedHashMap：** 

- 是HashMap的一个子类，保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的。
- 也可以在构造时用带参数，按照应用次数排序。
- 在遍历的时候会比HashMap慢，不过有种情况例外，当HashMap容量很大，实际数据较少时，遍历起来可能会比 LinkedHashMap慢，因为LinkedHashMap的遍历速度只和实际数据有关，和容量无关，而HashMap的遍历速度和他的容量有关。

**TreeMap：**

- 实现SortMap接口，能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator 遍历TreeMap时，得到的记录是排过序的，底层是红黑树。

一般情况下，我们用的最多的是HashMap，在Map 中插入、删除和定位元素，HashMap 是最好的选择。

但如果您要按自然顺序或自定义顺序遍历键，那么TreeMap会更好。

如果需要输出的顺序和输入的相同，那么用LinkedHashMap 可以实现，它还可以按读取顺序来排列.

**ConcurrentHashMap：**

- 是线程同步的HashMap，
- 底层是使用分段锁的方式来实现线程同步：
  - 一个ConcurrentHashMap分为多个段Segment，而一个段有分为多个HashEntry，HashEntry就是实际存储值的地方。
  - 当线程只读ConcurrentHashMap时，不需要加锁，只有当写ConcurrentHashMap时才会对对应的段加锁，而其余的段不受影响。
  - HashEntry解决冲突的方法是拉链法，当链表的长度大于8时，会将链表变成红黑树，从而改善查找的性能。



#### 为什么集合类没有实现Cloneable和Serializable接口？ 

克隆(cloning)或者是序列化(serialization)的**语义和含义是跟具体的实现相关的。**

因此，应该由集合类的具体实现来决定如何被克隆或者是序列化。



#### 什么是迭代器(Iterator)？  

Iterator接口提供了很多对集合元素进行迭代的方法。每一个集合类都包含了可以返回迭代器实例的



#### Iterator和ListIterator的区别是什么？ 

- Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List。
- Iterator对集合只能是前向遍历，ListIterator既可以前向也可以后向。
- ListIterator实现了Iterator接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。 



## 2.2 Java容器类



## 2.3多线程与并发

#### 进程和线程的区别是什么？

进程是执行着的应用程序，而线程是进程内部的一个执行序列。一个进程可以有多个线程。线程又叫做轻量级进程。

**线程与进程的区别归纳：**

**a.地址空间和其它资源**：进程间相互独立，同一进程的各线程间共享。某进程内的线程在其它进程不可见。

**b.通信：**进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。

**c.调度和切换**：线程上下文切换比进程上下文切换要快得多。

d.在多线程OS中，进程不是一个可执行的实体。



#### 创建线程有几种不同的方式？你喜欢哪一种？为什么？ 

有4种方式可以用来创建线程：

- 继承Thread类
- 实现Runnable接口
- 使用Executor框架来创建线程池 
- 实现Callable接口

实现Runnable接口这种方式更受欢迎：

- 因为这不需要继承Thread类。在应用设计中已经继承了别的对象的情况下，这需要多继承（而Java不支持多继承），只能实现接口。
- 线程池也是非常高效的，很容易实现和使用 



####  线程的几种可用状态？

![](https://azhu12138.oss-cn-shenzhen.aliyuncs.com/img/20210524203940.png)



####  同步方法和同步代码块的区别是什么？ 

- 同步方法默认用this或者当前类class对象作为锁；
- 同步代码块可以选择以什么来加锁，比同步方法要更细颗粒度，我们可以选择只同步会发生同步问题的部分代码而不是整个方法；
- 同步方法使用关键字`synchronized`修饰方法，而同步代码块主要是修饰需要进行同步的代码，用  `synchronized（object）{代码内容}`进行修饰；



#### 在监视器(Monitor)内部，是如何做线程同步的？程序应该做哪种级别的同步？ 

监视器和锁在Java虚拟机中是一块使用的。

- 监视器监视一块同步代码块，确保一次只有一个线程执行同步代码块。
- 每一个监视器都和一个对象引用相关联。线程在获取锁之前不允许执行同步代码。 



#### 什么是死锁(deadlock)？ 

死锁是指多个进程因竞争资源而造成的一种僵局（互相等待），若无外力作用，这些进程都将无法向前推进。死锁产生的4个必要条件：

- **互斥**：进程要求对所分配的资源（如打印机）进行排他性控制，即在一段时间内某 资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。
- **不可抢占**：进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能 由获得该资源的进程自己来释放（只能是主动释放)。
- **请求和保持**：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源 已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。
- **循环等待**：存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被 链中下一个进程所请求。



#### 如何确保N个线程可以访问N个资源同时又不导致死锁？ 

使用多线程的时候，一种非常简单的避免死锁的方式就是：

- 指定获取锁的顺序，并强制线程按照指定的顺序获取锁。

因此，如果所有的线程都是以同样的顺序加锁和释放锁，就不会出现死锁了。 





## 2.4 Java虚拟机-JVM

#### 类文件结构？

- 无符号数：基本的数据类型，如：u1,u2,u3
- 表：又无符号数或者表组合而成，

class文件包含的内容：

- 魔数：4B，0xCAFEBABE
- class文件的版本：4B，次版本+主版本
- 常量池：
  - 字面量：类似java的常量
  - 符号引用：
- 访问标志：2B，标志类或接口的访问信息
- 类索引、父类索引、接口索引集合：确定继承关系
- 字段表集合：
  - 字段表：描述声明的变量
- 方法表集合：
- 属性表集合：



#### 字节码指令？

- 加载和存储指令：将数据在栈帧中的局部变量表和操作数栈之间传输。
- 运算指令：
- 类型转换指令：
- 对象创建和访问指令：
- 操作数栈管理指令：
- 控制转移指令：
- 方法调用和返回指令：
- 异常处理指令：
- 同步指令：



#### class文件结构的特点？

- 平台中立
- 紧凑
- 稳定
- 可扩展



#### 类加载机制？

JVM将描述类的数据从class文件加载到内存，对数据进行校验、转换解析和初始化，形成可以被虚拟机直接使用的java类型。



#### 类加载过程？

![](https://azhu12138.oss-cn-shenzhen.aliyuncs.com/img/20210523154358.png)

- 加载：
  - 全限定类名获得对应字节流
  - 将该字节流代表的静态存储结构转化为方法区的运行时结构
  - 再内存中生成该类的class对象。
- 验证：确保class文件的字节流符合《java虚拟机规范》的约束要求
  - 文件格式验证
  - 元数据验证
  - 字节码验证
  - 符号引用验证
- 准备：为静态变量分配内存、设置初始值
- 解析：将符号引用转为直接引用
  - 类或接口的解析
  - 字段解析
  - 方法解析
  - 接口方法解析
- 初始化：



#### 双亲委派模型？

![](https://azhu12138.oss-cn-shenzhen.aliyuncs.com/img/20210523155845.png)











## 2.5新特性





# 3、数据库

## 3.1数据库理论



## 3.2 MySQL



## 3.3 Redis



# 4、框架

## 4.1 Spring

#### Spring中自动装配的方式有哪些？

- no：不进行自动装配，手动设置Bean的依赖关系。
- **byName：根据Bean的名字进行自动装配。**
- **byType：根据Bean的类型进行自动装配。**
- constructor：类似于byType，不过是应用于构造器的参数，如果正好有一个Bean与构造器的参数类型相同则可以自动装配，否则会导致错误。
- autodetect：如果有默认的构造器，则通过constructor的方式进行自动装配，否则使用byType的方式进行自动装配。

自动装配没有自定义装配方式那么精确，而且不能自动装配简单属性（基本类型、字符串等），在使用时应注意。











## 4.2 MyBatis



## 4.3 Netty



## 4.4 ZooKeeper



# 5、系统设计

## 5.1分布式与微服务



## 5.2安全



## 5.3容器技术Docker



## 5.4中间件



# 6、工具

## 6.1 Git



## 6.2 Maven



# 7、Linux

## 7.1常用命令



## 7.2 Shell脚本编程



## 7.3 Linux内核



# 8、设计模式



# 9、运维



# 10、前端

## 10.1前端基础



## 10.2前端框架

